[{"path":"https://lambdamoses.github.io/SFEWorkshop2024/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Lambda Moses Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"spatialfeatureexperiment","dir":"Articles","previous_headings":"","what":"SpatialFeatureExperiment","title":"Images and transcript spots in SFE","text":"SpatialFeatureExperiment (SFE) new S4 class built top SpatialExperiment (SPE). SFE incorporates geometries geometric operations sf package. Examples supported geometries Visium spots represented polygons corresponding size, cell nuclei segmentation polygons, tissue boundary polygons, pathologist annotation histological regions, transcript spots genes. Using sf, SpatialFeatureExperiment leverages GEOS C++ library underlying sf geometry operations, including algorithms determining whether geometries intersect, finding intersection geometries, buffering geometries margins, etc. schematic SFE object shown :  list SFE features extend SPE object: colGeometries sf data frames associated entities correspond columns gene count matrix, Visium spots cells. geometries sf data frames can Visium spot centroids, Visium spot polygons, datasets single cell resolution, cell nuclei segmentations. Multiple colGeometries can stored SFE object, one cell segmentation another nuclei segmentation. can non-spatial, attribute columns colGeometry rather colData, sf class allows users specify attributes relate geometries, “constant”, “aggregate”, “identity”. See agr argument st_sf documentation. colGraphs spatial neighborhood graphs cells spots. graphs class listw (spdep package), colPairs SingleCellExperiment used conversion necessary use numerous spatial dependency functions spdep, Moran’s , Geary’s C, Getis-Ord Gi*, LOSH, etc. Conversion also needed classical spatial statistics packages spatialreg adespatial. rowGeometries similar colGeometries, support entities correspond rows gene count matrix, genes. shall see , use case store transcript spots gene smFISH situ sequencing based datasets. rowGraphs similar colGraphs. potential use case may spatial colocalization transcripts different genes. annotGeometries sf data frames associated dataset directly gene count matrix, tissue boundaries, histological regions, cell nuclei segmentation Visium datasets, etc. geometries stored object facilitate plotting using sf operations find number nuclei Visium spot histological regions Visium spot intersects. Unlike colGeometries rowGeometries, number rows sf data frames annotGeometries constrained dimension gene count matrix can arbitrary. annotGraphs similar colGraphs rowGraphs, entities directly associated gene count matrix, spatial neighborhood graphs nuclei Visium datasets, objects like myofibers. graphs relevant spdep analyses attributes geometries spatial autocorrelation morphological metrics myofibers nuclei. geometry operations sf, attributes results analyses attributes (e.g. spatial regions defined attributes) may related back gene expression. localResults similar reducedDims SingleCellExperiment, stores results univariate bivariate local spatial analysis results, localmoran, Getis-Ord Gi*, local spatial heteroscedasticity (LOSH). Unlike reducedDims, type results (type type analysis Getis-Ord Gi*), feature (e.g. gene) pair features analysis performed results. local spatial analyses can also performed attributes colGeometries annotGeometries addition gene expression colData. Results multivariate spatial analysis MULTISPATI PCA can stored reducedDims. imgData store images associated dataset. field inherited SPE, SFE extended image functionalities images loaded memory unless necessary. material either taken documentation websites SpatialFeatureExperiment Voyager (release version; devel version: SFE, Voyager) added . topics covered details documentation websites. rendered version workshop can seen .","code":"library(Matrix) library(sf) library(fs) # I put it after sf intentionally library(terra) library(ggplot2) library(SingleCellExperiment) library(Seurat) library(scater) library(SpatialExperiment) library(SpatialFeatureExperiment) library(SFEData) library(Voyager) library(EBImage) library(scales) library(patchwork) library(dplyr) library(tidyr) library(tibble) library(stringr) library(arrow) library(sparseMatrixStats) library(metrica) theme_set(theme_bw())"},{"path":[]},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"from-scratch","dir":"Articles","previous_headings":"SFE object construction","what":"From scratch","title":"Images and transcript spots in SFE","text":"SFE object can constructed scratch assay matrices metadata. toy example, dgCMatrix used, since SFE inherits SingleCellExperiment (SCE), types arrays supported SCE delayed arrays also work. sufficient create SPE object, SFE object, even though sf data frame constructed geometries. constructor behaves similarly SPE constructor. centroid coordinates Visium spots toy example can converted spot polygons spotDiameter argument. Spot diameter pixels full resolution image can found scalefactors_json.json file Space Ranger output.","code":"# Visium barcode location from Space Ranger data(\"visium_row_col\") coords1 <- visium_row_col[visium_row_col$col < 6 & visium_row_col$row < 6,] coords1$row <- coords1$row * sqrt(3)  # Random toy sparse matrix set.seed(29) col_inds <- sample(1:13, 13) row_inds <- sample(1:5, 13, replace = TRUE) values <- sample(1:5, 13, replace = TRUE) mat <- sparseMatrix(i = row_inds, j = col_inds, x = values) colnames(mat) <- coords1$barcode rownames(mat) <- sample(LETTERS, 5) sfe3 <- SpatialFeatureExperiment(list(counts = mat), colData = coords1,                                 spatialCoordsNames = c(\"col\", \"row\"),                                 spotDiameter = 0.7)"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"space-ranger-output","dir":"Articles","previous_headings":"SFE object construction","what":"Space Ranger output","title":"Images and transcript spots in SFE","text":"Space Ranger output can read similar manner SpatialExperiment; returned SFE object spotPoly column geometry spot polygons. filtered matrix read , column graph called visium also present, spatial neighborhood graph Visium spots tissue. graph computed spots read regardless whether tissue. Inside outs directory: also raw_feature_bc_matrix though toy example filtered matrix. Inside matrix directory: Inside spatial directory: Visium datasets files . barcode_fluorescence_intensity.csv file present datasets fluorescent imaging rather bright field H&E. workshop focuses imaging based data Xenium MERFISH; see SFE vignette details Visium. example old fashioned Visium; working read function vignette higher resolution VisiumHD data.","code":"dir <- system.file(\"extdata\", package = \"SpatialFeatureExperiment\") sample_ids <- c(\"sample01\", \"sample02\") (samples <- file.path(dir, sample_ids)) #> [1] \"/usr/local/lib/R/site-library/SpatialFeatureExperiment/extdata/sample01\" #> [2] \"/usr/local/lib/R/site-library/SpatialFeatureExperiment/extdata/sample02\" list.files(file.path(samples[1], \"outs\")) #> [1] \"filtered_feature_bc_matrix\" \"spatial\" list.files(file.path(samples[1], \"outs\", \"filtered_feature_bc_matrix\")) #> [1] \"barcodes.tsv\" \"features.tsv\" \"matrix.mtx\" list.files(file.path(samples[1], \"outs\", \"spatial\")) #> [1] \"aligned_fiducials.jpg\"              \"barcode_fluorescence_intensity.csv\" #> [3] \"detected_tissue_image.jpg\"          \"scalefactors_json.json\"             #> [5] \"spatial_enrichment.csv\"             \"tissue_hires_image.png\"             #> [7] \"tissue_lowres_image.png\"            \"tissue_positions.csv\" (sfe3 <- read10xVisiumSFE(samples, sample_id = sample_ids, type = \"sparse\",                            data = \"filtered\", images = \"hires\")) #> >>> 10X Visium data will be loaded: sample01 #> >>> Adding spatial neighborhood graph to sample01 #> >>> 10X Visium data will be loaded: sample02 #> >>> Adding spatial neighborhood graph to sample02 #> class: SpatialFeatureExperiment  #> dim: 5 25  #> metadata(0): #> assays(1): counts #> rownames(5): ENSG00000014257 ENSG00000142515 ENSG00000263639 #>   ENSG00000163810 ENSG00000149591 #> rowData names(14): symbol Feature.Type ... #>   Median.Normalized.Average.Counts_sample02 #>   Barcodes.Detected.per.Feature_sample02 #> colnames(25): GTGGCGTGCACCAGAG-1 GGTCCCATAACATAGA-1 ... #>   TGCAATTTGGGCACGG-1 ATGCCAATCGCTCTGC-1 #> colData names(10): in_tissue array_row ... channel3_mean channel3_stdev #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: full_res_image_pixel #> Geometries: #> colGeometries: spotPoly (POLYGON)  #>  #> Graphs: #> sample01: col: visium #> sample02: col: visium"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"vizgen-merfish-output","dir":"Articles","previous_headings":"SFE object construction","what":"Vizgen MERFISH output","title":"Images and transcript spots in SFE","text":"commercialized MERFISH Vizgen standard output format, can read SFE readVizgen(). cell segmentation field view (FOV) separate HDF5 file MERFISH dataset can hundreds FOVs, strongly recommend reading MERFISH output server large number CPU cores. Alternatively, MERFISH datasets store cell segmentation parquet file, can easily read R. requires installation arrow. SFEData package (version 1.6.0 later) provides smaller subsets data standard output format MERFISH, Xenium, CosMX testing example purposes via *Output functions. read toy dataset first FOV real dataset; note first time run code, code chink notebook appears stall need go R console type Yes download dataset: Cell segmentations CellPose cell_boundaries.parquet file, already GeoParquet, means already Simple Features rather just coordinates vertices. conversion reformatting needed. optional add_molecules argument can set TRUE read transcript spots; behind scene, calls formatTxSpots() function, can also called separately. unit always microns. make easier faster read data next time, transcript spots written file detected_transcripts.parquet directory data resides: GeoParquet file much smaller original CSV file; parquet Apache Arrow designed memory efficient faster read CSV files supported many different programming languages, facilitating interoperability:","code":"fp <- tempdir() dir_use <- VizgenOutput(file_path = file.path(fp, \"vizgen\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> The downloaded files are in /tmp/RtmpOVsuEd/vizgen/vizgen_cellbound dir_tree(dir_use) #> /tmp/RtmpOVsuEd/vizgen/vizgen_cellbound #> ├── cell_boundaries #> │   ├── feature_data_z2_z3_1.hdf5 #> │   ├── feature_data_z2_z3_2.hdf5 #> │   ├── feature_data_z2_z3_3.hdf5 #> │   └── feature_data_z2_z3_4.hdf5 #> ├── cell_boundaries.parquet #> ├── cell_by_gene.csv #> ├── cell_metadata.csv #> ├── detected_transcripts.csv #> └── images #>     ├── manifest.json #>     ├── mosaic_Cellbound1_z3.tif #>     ├── mosaic_Cellbound2_z1.tif #>     ├── mosaic_Cellbound2_z3.tif #>     ├── mosaic_Cellbound3_z3.tif #>     ├── mosaic_DAPI_z1.tif #>     ├── mosaic_DAPI_z2.tif #>     ├── mosaic_DAPI_z3.tif #>     ├── mosaic_PolyT_z2.tif #>     └── mosaic_PolyT_z3.tif (sfe_mer <- readVizgen(dir_use, z = 3L, add_molecules = TRUE)) #> >>> 1 `.parquet` files exist: #> /tmp/RtmpOVsuEd/vizgen/vizgen_cellbound/cell_boundaries.parquet #> >>> using -> /tmp/RtmpOVsuEd/vizgen/vizgen_cellbound/cell_boundaries.parquet #> >>> Cell segmentations are found in `.parquet` file #> Removing 35 cells with area less than 15 #> >>> filtering geometries to match 1023 cells with counts > 0 #> >>> Checking polygon validity #> >>> Reading transcript coordinates #> >>> Converting transcript spots to geometry #> >>> Writing reformatted transcript spots to disk #> class: SpatialFeatureExperiment  #> dim: 88 1023  #> metadata(0): #> assays(1): counts #> rownames(88): CD4 TLL1 ... Blank-38 Blank-39 #> rowData names(0): #> colnames(1023): 112824700230101267 112824700230101269 ... #>   112824700330100848 112824700330100920 #> colData names(11): fov volume ... solidity sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : center_x center_y #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: micron #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #> rowGeometries: txSpots (MULTIPOINT)  #>  #> Graphs: #> sample01: dir_tree(dir_use) #> /tmp/RtmpOVsuEd/vizgen/vizgen_cellbound #> ├── cell_boundaries #> │   ├── feature_data_z2_z3_1.hdf5 #> │   ├── feature_data_z2_z3_2.hdf5 #> │   ├── feature_data_z2_z3_3.hdf5 #> │   └── feature_data_z2_z3_4.hdf5 #> ├── cell_boundaries.parquet #> ├── cell_by_gene.csv #> ├── cell_metadata.csv #> ├── detected_transcripts.csv #> ├── detected_transcripts.parquet #> └── images #>     ├── manifest.json #>     ├── mosaic_Cellbound1_z3.tif #>     ├── mosaic_Cellbound2_z1.tif #>     ├── mosaic_Cellbound2_z3.tif #>     ├── mosaic_Cellbound3_z3.tif #>     ├── mosaic_DAPI_z1.tif #>     ├── mosaic_DAPI_z2.tif #>     ├── mosaic_DAPI_z3.tif #>     ├── mosaic_PolyT_z2.tif #>     └── mosaic_PolyT_z3.tif file_size(file.path(dir_use, \"detected_transcripts.csv\")) #> 828K file_size(file.path(dir_use, \"detected_transcripts.parquet\")) #> 27.7K"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"x-xenium-output","dir":"Articles","previous_headings":"SFE object construction","what":"10X Xenium output","title":"Images and transcript spots in SFE","text":"SFE supports reading output Xenium Onboarding Analysis (XOA) v1 v2 function readXenium(). Especially XOA v2, arrow strongly recommended. cell nuclei polygon vertices transcript spot coordinates parquet files (GeoParquet). readXenium() makes sf data frames vertices transcript spots saves GeoParquet files. processed cell segmentation written cell_boundaries_sf.parquet GeoParquet faster reading next time, nucleus segmentation nucleus_boundaries_sf.parquet, transcript spots tx_spots.parquet. upcoming Xenium Prime (XOA v3) 5k gene panel poses challenge readXenium function making GeoParquet file. Writing GeoParquet file may fail due error might related ’s specific R interface arrow. 5k panel datasets larger numbers cells, may write multiple GeoParquet files concatenate DuckDB next release. addition, large GeoParquet transcript spot files, GDAL Parquet driver (requires GDAL version 3.5.0 higher), can selectively load transcript spots genes interest, e.g. visualization purposes, readSelectTx() function. beginning disk shadow SFE object. Genentech’s ArtifactDB project aims implement language-agnostic -disk serialization objects matrices, SingleCellExperiment, SpatialExperiment facilitate interoperability programming languages. R, serialization performed alabaster series packages Bioconductor. GeoParquet files can beginning alabaster.sfe whose non-geometric aspects handled existing alabaster.sce alabaster.spatial.","code":"dir_use <- XeniumOutput(\"v2\", file_path = file.path(fp, \"xenium\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> The downloaded files are in /tmp/RtmpOVsuEd/xenium/xenium2 dir_tree(dir_use) #> /tmp/RtmpOVsuEd/xenium/xenium2 #> ├── cell_boundaries.csv.gz #> ├── cell_boundaries.parquet #> ├── cell_feature_matrix.h5 #> ├── cells.csv.gz #> ├── cells.parquet #> ├── experiment.xenium #> ├── morphology_focus #> │   ├── morphology_focus_0000.ome.tif #> │   ├── morphology_focus_0001.ome.tif #> │   ├── morphology_focus_0002.ome.tif #> │   └── morphology_focus_0003.ome.tif #> ├── nucleus_boundaries.csv.gz #> ├── nucleus_boundaries.parquet #> ├── transcripts.csv.gz #> └── transcripts.parquet # RBioFormats issue: https://github.com/aoles/RBioFormats/issues/42 try(sfe_xen <- readXenium(dir_use, add_molecules = TRUE)) #> >>> Must use gene symbols as row names when adding transcript spots. #> >>> Cell segmentations are found in `.parquet` file(s) #> >>> Reading cell and nucleus segmentations #> >>> Making MULTIPOLYGON nuclei geometries #> >>> Making POLYGON cell geometries #> >>> Checking polygon validity #> >>> Saving geometries to parquet files #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 6272 cells with counts > 0 #> >>> filtering nucSeg geometries to match 6158 cells with counts > 0 #> >>> Reading transcript coordinates #> >>> Converting transcript spots to geometry #> >>> Writing reformatted transcript spots to disk #> >>> Total of 116 features/genes with no transcript detected or `min_phred` < 20 are removed from SFE object #> >>> To keep all features -> set `min_phred = NULL` (sfe_xen <- readXenium(dir_use, add_molecules = TRUE)) #> >>> Must use gene symbols as row names when adding transcript spots. #> >>> Preprocessed sf segmentations found #> >>> Reading cell and nucleus segmentations #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 6272 cells with counts > 0 #> >>> filtering nucSeg geometries to match 6158 cells with counts > 0 #> >>> Reading transcript coordinates #> >>> Total of 116 features/genes with no transcript detected or `min_phred` < 20 are removed from SFE object #> >>> To keep all features -> set `min_phred = NULL` #> class: SpatialFeatureExperiment  #> dim: 398 6272  #> metadata(1): Samples #> assays(1): counts #> rownames(398): ABCC11 ACE2 ... UnassignedCodeword_0488 #>   UnassignedCodeword_0497 #> rowData names(3): ID Symbol Type #> colnames(6272): abclkehb-1 abcnopgp-1 ... odmgoega-1 odmgojlc-1 #> colData names(9): transcript_counts control_probe_counts ... #>   nucleus_area sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_centroid y_centroid #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: micron #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON), nucSeg (MULTIPOLYGON)  #> rowGeometries: txSpots (MULTIPOINT)  #>  #> Graphs: #> sample01: dir_tree(dir_use) #> /tmp/RtmpOVsuEd/xenium/xenium2 #> ├── cell_boundaries.csv.gz #> ├── cell_boundaries.parquet #> ├── cell_boundaries_sf.parquet #> ├── cell_feature_matrix.h5 #> ├── cells.csv.gz #> ├── cells.parquet #> ├── experiment.xenium #> ├── morphology_focus #> │   ├── morphology_focus_0000.ome.tif #> │   ├── morphology_focus_0001.ome.tif #> │   ├── morphology_focus_0002.ome.tif #> │   └── morphology_focus_0003.ome.tif #> ├── nucleus_boundaries.csv.gz #> ├── nucleus_boundaries.parquet #> ├── nucleus_boundaries_sf.parquet #> ├── transcripts.csv.gz #> ├── transcripts.parquet #> └── tx_spots.parquet"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"other-technologies","dir":"Articles","previous_headings":"SFE object construction","what":"Other technologies","title":"Images and transcript spots in SFE","text":"Nanostring CosMX data, including transcript spots, processed read similar manner MERFISH Xenium data, readCosMX() function. read function Visium HD progress. Contribution Akoya, Molecular Cartography, Curio Seeker welcome. See issues.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"coercion-from-spatialexperiment","dir":"Articles","previous_headings":"SFE object construction","what":"Coercion from SpatialExperiment","title":"Images and transcript spots in SFE","text":"existing spatial -omics data analysis packages use SPE. SPE objects can coerced SFE objects. column geometries spot diameter specified, column geometry called “centroids” created. coercion, column names must duplicate. images present SPE object, converted SpatRaster SPE object converted SFE. Plotting functions Voyager package require image classes implemented SFE (covered later workshop) plot image behind geometries classes SFE spatial extent needed make sure images aligned geometries coordinate system.","code":"spe <- read10xVisium(samples, sample_ids, type = \"sparse\", data = \"filtered\",    images = \"hires\", load = FALSE) colnames(spe) <- make.unique(colnames(spe), sep = \"-\") rownames(spatialCoords(spe)) <- colnames(spe) (sfe3 <- toSpatialFeatureExperiment(spe)) #> class: SpatialFeatureExperiment  #> dim: 5 25  #> metadata(0): #> assays(1): counts #> rownames(5): ENSG00000014257 ENSG00000142515 ENSG00000263639 #>   ENSG00000163810 ENSG00000149591 #> rowData names(1): symbol #> colnames(25): GTGGCGTGCACCAGAG-1 GGTCCCATAACATAGA-1 ... #>   TGCAATTTGGGCACGG-1 ATGCCAATCGCTCTGC-1 #> colData names(4): in_tissue array_row array_col sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: #> Geometries: #> colGeometries: centroids (POINT)  #>  #> Graphs: #> sample01:  #> sample02:"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"coercion-from-seurat","dir":"Articles","previous_headings":"SFE object construction","what":"Coercion from Seurat","title":"Images and transcript spots in SFE","text":"Seurat objects can coerced SFE objects though coercion SFE Seurat yet implemented.","code":"dir_extdata <- system.file(\"extdata\", package = \"SpatialFeatureExperiment\") obj_vis <- readRDS(file.path(dir_extdata, \"seu_vis_toy.rds\")) sfe_conv_vis <-   toSpatialFeatureExperiment(x = obj_vis,                               image_scalefactors = \"lowres\",                              unit = \"micron\",                              BPPARAM = BPPARAM) #> >>> Seurat Assays found: RNA #> >>> RNA -> will be used as 'Main Experiment' #> >>> Seurat spatial object found: VisiumV1 #> >>> 'full_res_image_pixel' units will be used -> #> ie 'imagerow' & 'imagecol' without scaling factors #> >>> set `unit = 'micron'` to convert spot coordinates to micron space #> >>> Generating `sf` geometries #> Warning: Layer 'data' is empty #> Warning: Layer 'scale.data' is empty #>  #> >>> Creating `SFE` object -> sample01 #> >>> Converting pixels to microns sfe_conv_vis #> class: SpatialFeatureExperiment  #> dim: 5 12  #> metadata(0): #> assays(1): counts #> rownames(5): ACPP KLK3 MSMB TGM4 TAGLN #> rowData names(0): #> colnames(12): GTGGCGTGCACCAGAG-1 GGTCCCATAACATAGA-1 ... #>   CTTCCTGCATATTTAC-1 CAATATGTAGATTTAC-1 #> colData names(7): orig.ident nCount_RNA ... in_tissue sample_id #> reducedDimNames(0): #> mainExpName: RNA #> altExpNames(0): #> spatialCoords names(2) : X Y #> imgData names(0): #>  #> unit: micron #> Geometries: #> colGeometries: spotPoly (POLYGON)  #>  #> Graphs: #> sample01:"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"getting-setting-and-plotting-fields-of-sfe-objects","dir":"Articles","previous_headings":"","what":"Getting, setting, and plotting fields of SFE objects","title":"Images and transcript spots in SFE","text":"demonstrate operations SFE objects Xenium MERFISH datasets read just now, introducing getters, setters, plotting functions along way flow basic exploratory analysis.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"singlecellexperiment-getters-and-setters","dir":"Articles","previous_headings":"Getting, setting, and plotting fields of SFE objects","what":"SingleCellExperiment getters and setters","title":"Images and transcript spots in SFE","text":"SFE object SCE object SFE builds top SCE, inherits SCE, SCE methods apply. “inherits” just like bioinformatician human, “bioinformatician” bit like SFE “human” like SCE. go SCE getters setters. center SCE gene count matrix. can get set gene count matrix counts function: gene count matrix read HDF5 file DelayedMatrix fully loaded memory; helps analyzing data doesn’t fit memory. See DelayedArray package info operations DelayedMatrix. log normalizing data, similarly logcounts() function can used get set log normalized gene count matrix. gene count matrix metadata cells genes. Use colData function get cell metadata rowData get gene metadata Just like Seurat, SCE object can subsetted like matrix, example, remove low quality cells transcript counts genes detected. colData columns SCE can accessed $ operator getting column data frame. comes data frame analogy, also see tidyOmics packages brings Tidyverse -omics data gives unified user interface uniting Seurat SCE analyses. PCA part standard scRNA-seq data analysis workflow. ’ll first normalize data perform PCA get PCA results. Using cell area size factors comes paper; using total counts scRNA-seq inappropriate curated gene panel can blunt biological signals. Later see Voyager spatial analysis functions modeled runPCA un user interface. reducedDim function can used get set dimension reduction results. User interfaces get set geometries spatial graphs emulate reducedDims row/colPairs SingleCellExperiment. Column row geometries also emulate reducedDims internal implementation, annotation geometries spatial graphs differ. dimension reductions present?","code":"m <- counts(sfe_xen) head(m) #> <6 x 6272> sparse DelayedMatrix object of type \"double\": #>        abclkehb-1 abcnopgp-1 abcobdon-1 ... odmgoega-1 odmgojlc-1 #> ABCC11          0          0          0   .          0          0 #> ACE2            1          1          1   .          0          0 #> ACKR1           0          0          0   .          0          0 #> ACTA2           0          0          0   .          0          0 #> ACTG2           0          0          0   .          0          0 #> ADAM28          1          0          1   .          0          0 # Setter counts(sfe_xen) <- m colData(sfe_xen) #> DataFrame with 6272 rows and 9 columns #>            transcript_counts control_probe_counts control_codeword_counts #>                    <integer>            <integer>               <integer> #> abclkehb-1                26                    0                       0 #> abcnopgp-1                35                    0                       0 #> abcobdon-1                39                    0                       0 #> abcohgbl-1                45                    0                       0 #> abcoochm-1                61                    0                       0 #> ...                      ...                  ...                     ... #> odmfjplg-1                12                    0                       0 #> odmfpjop-1                 3                    0                       0 #> odmglico-1                40                    0                       0 #> odmgoega-1                25                    0                       0 #> odmgojlc-1                13                    0                       0 #>            unassigned_codeword_counts deprecated_codeword_counts total_counts #>                             <integer>                  <integer>    <integer> #> abclkehb-1                          0                          0           26 #> abcnopgp-1                          0                          0           35 #> abcobdon-1                          0                          0           39 #> abcohgbl-1                          0                          0           45 #> abcoochm-1                          0                          0           61 #> ...                               ...                        ...          ... #> odmfjplg-1                          0                          0           12 #> odmfpjop-1                          0                          0            3 #> odmglico-1                          0                          0           40 #> odmgoega-1                          0                          0           25 #> odmgojlc-1                          0                          0           13 #>            cell_area nucleus_area   sample_id #>            <numeric>    <numeric> <character> #> abclkehb-1   39.6923      18.9656    sample01 #> abcnopgp-1   60.7352      29.5322    sample01 #> abcobdon-1   55.4519      20.9977    sample01 #> abcohgbl-1   79.9266      24.4295    sample01 #> abcoochm-1   70.6244      34.1833    sample01 #> ...              ...          ...         ... #> odmfjplg-1  63.03813     29.35156    sample01 #> odmfpjop-1   9.16672      9.16672    sample01 #> odmglico-1  82.54563     16.07563    sample01 #> odmgoega-1 112.84547      5.73484    sample01 #> odmgojlc-1  47.00766     12.19219    sample01 rowData(sfe_xen) #> DataFrame with 398 rows and 3 columns #>                                             ID                 Symbol #>                                    <character>            <character> #> ABCC11                         ENSG00000121270                 ABCC11 #> ACE2                           ENSG00000130234                   ACE2 #> ACKR1                          ENSG00000213088                  ACKR1 #> ACTA2                          ENSG00000107796                  ACTA2 #> ACTG2                          ENSG00000163017                  ACTG2 #> ...                                        ...                    ... #> UnassignedCodeword_0461 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0469 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0479 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0488 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0497 UnassignedCodeword_0.. UnassignedCodeword_0.. #>                                        Type #>                                 <character> #> ABCC11                      Gene Expression #> ACE2                        Gene Expression #> ACKR1                       Gene Expression #> ACTA2                       Gene Expression #> ACTG2                       Gene Expression #> ...                                     ... #> UnassignedCodeword_0461 Unassigned Codeword #> UnassignedCodeword_0469 Unassigned Codeword #> UnassignedCodeword_0479 Unassigned Codeword #> UnassignedCodeword_0488 Unassigned Codeword #> UnassignedCodeword_0497 Unassigned Codeword sfe_xen <- sfe_xen[, sfe_xen$total_counts > 5] sfe_xen <- sfe_xen[rowSums(counts(sfe_xen)) > 0,] dim(sfe_xen) #> [1]  394 5749 sfe_xen <- logNormCounts(sfe_xen, size.factors = sfe_xen$cell_area) # Log counts getter logcounts(sfe_xen) |> head() #> <6 x 5749> sparse DelayedMatrix object of type \"double\": #>        abclkehb-1 abcnopgp-1 abcobdon-1 ... odmgoega-1 odmgojlc-1 #> ABCC11   0.000000   0.000000   0.000000   .          0          0 #> ACE2     1.346809   1.006276   1.073702   .          0          0 #> ACKR1    0.000000   0.000000   0.000000   .          0          0 #> ACTA2    0.000000   0.000000   0.000000   .          0          0 #> ACTG2    0.000000   0.000000   0.000000   .          0          0 #> ADAM28   1.346809   0.000000   1.073702   .          0          0 sfe_xen <- runPCA(sfe_xen, ncomponents = 20,                   exprs_values = \"logcounts\", scale = TRUE) pca_res <- reducedDim(sfe_xen, \"PCA\") head(pca_res) #>                 PC1       PC2         PC3       PC4        PC5        PC6 #> abclkehb-1 4.104976 -5.209892 -0.32024759 -3.448198 -0.8745107 -1.4135185 #> abcnopgp-1 3.698699 -3.204301  0.37888409 -2.166183 -0.3577043 -0.6102030 #> abcobdon-1 3.684348 -3.824745 -0.26077213 -2.621562 -0.8730314 -0.2183592 #> abcohgbl-1 3.575645 -4.547060  0.01390075 -3.020987 -0.5612930 -0.9650647 #> abcoochm-1 5.867807 -4.898515  0.19077378 -2.473097 -2.1675873 -2.8156440 #> abcoplda-1 3.219883 -5.331865  0.42655776 -3.515862 -0.9702069 -1.5188901 #>                   PC7        PC8         PC9     PC10       PC11       PC12 #> abclkehb-1 -0.9713220 -1.9336509 -0.08400579 3.588110 -0.1042168 -0.6512118 #> abcnopgp-1 -0.1503387 -0.4381665 -0.23839749 2.898649 -0.8889157 -0.8333472 #> abcobdon-1 -0.7347887 -0.6500136 -0.04385059 1.688362 -0.9957585 -0.7186998 #> abcohgbl-1 -0.6458784 -1.3219623 -0.27045651 2.627548 -0.3681193 -0.6257008 #> abcoochm-1 -0.3622780 -1.9080242  0.11771026 2.126753 -0.4656962 -1.3993553 #> abcoplda-1  0.5366565 -1.2170732 -1.47320560 2.013572 -0.6720101 -0.9997679 #>                  PC13        PC14        PC15       PC16       PC17        PC18 #> abclkehb-1 -1.1038552  0.90477874 -0.13758657  1.0476007  1.2129374 -0.97232802 #> abcnopgp-1 -0.2487955  0.09489004 -0.79986738 -0.7257234  0.6517269  0.59408468 #> abcobdon-1 -0.6272968 -0.16732126 -0.64625317 -0.3599726  0.2004521 -1.14290957 #> abcohgbl-1 -0.1259936  0.15850392  1.64506087  0.8239103  0.3532861 -0.72690582 #> abcoochm-1  1.3791996 -0.12748514  0.04746375  0.7644174  0.4889616  0.09668229 #> abcoplda-1 -0.1754514 -0.24161746 -0.12717546  0.3201031 -0.2695271 -1.72548119 #>                  PC19       PC20 #> abclkehb-1 -0.3029037  1.1541254 #> abcnopgp-1  0.2247111 -0.3280252 #> abcobdon-1  0.4850882  0.8060317 #> abcohgbl-1 -0.9053308 -0.2138684 #> abcoochm-1 -0.4697169  0.8896973 #> abcoplda-1  0.4623914 -0.9390845 # Set PCA embeddings say if you ran PCA elsewhere reducedDim(sfe_xen, \"PCA\") <- pca_res reducedDimNames(sfe_xen) #> [1] \"PCA\""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"column-geometries","dir":"Articles","previous_headings":"Getting, setting, and plotting fields of SFE objects","what":"Column geometries","title":"Images and transcript spots in SFE","text":"Column geometries colGeometries geometries correspond columns gene count matrix, Visium spots cells datasets single cell resolution technology. SFE object can multiple column geometries. example, dataset single cell resolution, whole cell segmentation nuclei segmentation two different colGeometries. However, Visium, spot polygons colGeometry obviously relevant, though users can add geometries results geometric operations spot polygons. different geometries can get set names; “spotPoly” standard name Visium spot polygons, “cellSeg” cell segmentation, “nucSeg” nucleus segmentation. name can used; say cell segmentations different algorithms can stored different names, say “CellPost” “watershed”, although different segmentations can lead different grene counts per cell different number cells. get sf data frame, just like regular data frame special geometry column. Now plot cells  Voyager package can plot geometries without data plotGeometry() function. Note arguments changed since version 1.7.0 (devel version)  bounding box can used zoom smaller region plotGeometry geometry plotting function Voyager plotSpatialFeature.  Multiple geometries, cells nuclei, can plotted (supported version 1.7.0 later)  see colGeometries present SFE object: shorthands specific column row geometries. example, spotPoly(sfe) equivalent colGeometry(sfe, \"spotPoly\"), cellSeg(sfe) equivalent colGeometry(sfe, \"cellSeg\"), nucSeg(sfe) colGeometry(sfe, \"nucSeg\"). Exercise: Get plot nucleus segmentations sfe_xen DelayedArray large gene count matrices don’t fit memory, present geometries memory. haven’t gotten memory problems geometries even hundreds thousands cell polygons 2017 MacBook Pro 8 GB RAM yet. future version, may try sedona DuckDB combined sdf general sf allow geometric operations without loading everything memory.","code":"# Get Visium spot polygons (cells <- colGeometry(sfe_xen, \"cellSeg\")) #> Simple feature collection with 5749 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: -1008.1 xmax: 1026.163 ymax: 0 #> CRS:           NA #> First 10 features: #>            label_id                       geometry #> abclkehb-1      703 POLYGON ((389.9376 -922.462... #> abcnopgp-1      704 POLYGON ((378.8875 -934.787... #> abcobdon-1      705 POLYGON ((381.4376 -931.6, ... #> abcohgbl-1      706 POLYGON ((386.7501 -925.225... #> abcoochm-1      707 POLYGON ((416.075 -896.9625... #> abcoplda-1      708 POLYGON ((401.6251 -909.925... #> abcopngk-1      709 POLYGON ((415.0125 -911.412... #> abcphhlp-1      710 POLYGON ((407.575 -906.525,... #> abcpmfic-1      711 POLYGON ((420.1125 -905.462... #> abdaapec-1      712 POLYGON ((408.85 -900.3625,... ggplot(cells) + geom_sf() plotGeometry(sfe_xen, colGeometryName = \"cellSeg\", show_axes = TRUE) +     plotGeometry(sfe_xen, colGeometryName = \"cellSeg\", show_axes = TRUE, dark = TRUE) bbox <- c(xmin = 0, xmax = 200, ymin = -600, ymax = -400) plotGeometry(sfe_xen, colGeometryName = \"cellSeg\", bbox = bbox) plotGeometry(sfe_xen, colGeometryName = c(\"cellSeg\", \"nucSeg\"), bbox = bbox) # Set colGeometry colGeometry(sfe_xen, \"cellSeg\") <- cells colGeometryNames(sfe_xen) #> [1] \"centroids\" \"cellSeg\"   \"nucSeg\" # Getter (cells <- cellSeg(sfe_xen)) #> Simple feature collection with 5749 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: -1008.1 xmax: 1026.163 ymax: 0 #> CRS:           NA #> First 10 features: #>            label_id                       geometry #> abclkehb-1      703 POLYGON ((389.9376 -922.462... #> abcnopgp-1      704 POLYGON ((378.8875 -934.787... #> abcobdon-1      705 POLYGON ((381.4376 -931.6, ... #> abcohgbl-1      706 POLYGON ((386.7501 -925.225... #> abcoochm-1      707 POLYGON ((416.075 -896.9625... #> abcoplda-1      708 POLYGON ((401.6251 -909.925... #> abcopngk-1      709 POLYGON ((415.0125 -911.412... #> abcphhlp-1      710 POLYGON ((407.575 -906.525,... #> abcpmfic-1      711 POLYGON ((420.1125 -905.462... #> abdaapec-1      712 POLYGON ((408.85 -900.3625,... # Setter cellSeg(sfe_xen) <- cells"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"row-geometries","dir":"Articles","previous_headings":"Getting, setting, and plotting fields of SFE objects","what":"Row geometries","title":"Images and transcript spots in SFE","text":"rowGeometry getter setter pretty much user interface getters setters covered : Note MULTIPOINT Z ; 3D. Geometric operations sf finding intersections work 3D geometries x y dimensions, z, geographical space, largely live surface Earth. mostly fine histological space well vast majority spatial -omics data come thin sections much higher x y resolution much larger x y extent z, although 3D datasets numerous serial sections thick sections 3D cell segmentations. Since cases, data usually come discrete z-planes, might just use multiple polygon geometry columns one z-plane instead something like mesh CGI tradition. case transcript spots, ’s special convenience function txSpots; haven’t thought use rowGeometries kept general, allowing type geometry, case use cases come . plotGeometry() function can plot transcript spots, genes selected genes, distinguished point shape.  ’s still lot spots, definitely overplotting. Transcript spot density can plotted 2D histogram, using 20 micron hexagonal grid show density transcripts genes  Plot genes :  plot transcript spots geometries  Transcript spots can also plotted along cell level data  plot dark theme  cell level data transcript spots genes plotted, gene plotted separate panel  Note transcript spots cells; spots rowGeometires don’t assigned cells. transcript spots data subset fits memory, GDAL Parquet driver available, plotting functions can call readSelectTx() behind scene selectively read transcripts genes rather genes. transcript spots sf data frames. Recent versions sf can convertsf objects spatstat package spatial point pattern analyses.","code":"(rg <- rowGeometry(sfe_xen, \"txSpots\")) #> Simple feature collection with 394 features and 2 fields #> Geometry type: MULTIPOINT #> Dimension:     XYZ #> Bounding box:  xmin: 0.001159668 ymin: -1008.098 xmax: 1026.159 ymax: -4.473946 #> z_range:       zmin: 13.56251 zmax: 27.21318 #> CRS:           NA #> First 10 features: #>            gene codeword_index                       geometry #> ABCC11   ABCC11             87 MULTIPOINT Z ((111.2996 -47... #> ACE2       ACE2             31 MULTIPOINT Z ((204.9438 -21... #> ACKR1     ACKR1            349 MULTIPOINT Z ((8.244019 -88... #> ACTA2     ACTA2            342 MULTIPOINT Z ((4.195129 -40... #> ACTG2     ACTG2            231 MULTIPOINT Z ((6.257874 -30... #> ADAM28   ADAM28            119 MULTIPOINT Z ((0.2313232 -4... #> ADAMTS1 ADAMTS1            242 MULTIPOINT Z ((5.13385 -321... #> ADGRE1   ADGRE1             24 MULTIPOINT Z ((119.8132 -7.... #> ADGRL4   ADGRL4            132 MULTIPOINT Z ((4.375183 -32... #> ADH1C     ADH1C             92 MULTIPOINT Z ((1.244507 -59... # Setter rowGeometry(sfe_xen, \"txSpots\") <- rg txSpots(sfe_xen) #> Simple feature collection with 394 features and 2 fields #> Geometry type: MULTIPOINT #> Dimension:     XYZ #> Bounding box:  xmin: 0.001159668 ymin: -1008.098 xmax: 1026.159 ymax: -4.473946 #> z_range:       zmin: 13.56251 zmax: 27.21318 #> CRS:           NA #> First 10 features: #>            gene codeword_index                       geometry #> ABCC11   ABCC11             87 MULTIPOINT Z ((111.2996 -47... #> ACE2       ACE2             31 MULTIPOINT Z ((204.9438 -21... #> ACKR1     ACKR1            349 MULTIPOINT Z ((8.244019 -88... #> ACTA2     ACTA2            342 MULTIPOINT Z ((4.195129 -40... #> ACTG2     ACTG2            231 MULTIPOINT Z ((6.257874 -30... #> ADAM28   ADAM28            119 MULTIPOINT Z ((0.2313232 -4... #> ADAMTS1 ADAMTS1            242 MULTIPOINT Z ((5.13385 -321... #> ADGRE1   ADGRE1             24 MULTIPOINT Z ((119.8132 -7.... #> ADGRL4   ADGRL4            132 MULTIPOINT Z ((4.375183 -32... #> ADH1C     ADH1C             92 MULTIPOINT Z ((1.244507 -59... # bbox is used due to overplotting if plotting the entire example data plotGeometry(sfe_xen, rowGeometryName = \"txSpots\", bbox = bbox, gene = \"all\") plotTxBin2D(sfe_xen, binwidth = 20, hex = TRUE) set.seed(29) genes_use <- sample(rownames(sfe_xen)[rowData(sfe_xen)$Type == \"Gene Expression\"], 6) # Genes that don't have spots in this bbox are not plotted plotGeometry(sfe_xen, rowGeometryName = \"txSpots\", bbox = bbox, gene = genes_use) plotGeometry(sfe_xen, colGeometryName = c(\"cellSeg\", \"nucSeg\"),              rowGeometryName = \"txSpots\", bbox = bbox, gene = genes_use) plotSpatialFeature(sfe_xen, \"total_counts\", colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", rowGeometryFeatures = genes_use,                    bbox = bbox, tx_fixed = list(size = 1)) plotSpatialFeature(sfe_xen, \"total_counts\", colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", rowGeometryFeatures = genes_use,                    bbox = bbox, dark = TRUE,                    tx_fixed = list(size = 1, color = \"lightgray\")) plotSpatialFeature(sfe_xen, genes_use, colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", rowGeometryFeatures = genes_use,                    bbox = bbox)"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"annotation","dir":"Articles","previous_headings":"Getting, setting, and plotting fields of SFE objects","what":"Annotation","title":"Images and transcript spots in SFE","text":"Annotation geometries can get set annotGeometry(). column row geometries, number rows sf data frame (.e. number geometries data frame) constrained number rows columns gene count matrix respectively, just like rowData colData, row rowGeometry colGeometry sf data frame must correspond row column gene count matrix respectively. contrast, annotGeometry sf data frame can dimension, constrained dimension gene count matrix. Xenium dataset doesn’t come annotGeometries, used QuPath annotate just purpose demonstration testing. looks like two sides river section, ’s actually two separate pieces tissue original tissue 3 dimensional.  use plotGeometry   See annotGeometries present SFE object: shorthands specific annotation geometries. example, tissueBoundary(sfe) equivalent annotGeometry(sfe, \"tissueBoundary\"). cellSeg() (cell segmentation) nucSeg() (nuclei segmentation) first query colGeometries (single cell, single molecule technologies, equivalent colGeometry(sfe, \"cellSeg\") colGeometry(sfe, \"nucSeg\")), found, query annotGeometries (array capture microdissection technologies, equivalent annotGeometry(sfe, \"cellSeg\") annotGeometry(sfe, \"nucSeg\")).","code":"pieces <- readRDS(system.file(\"extdata/pieces.rds\", package = \"SpatialFeatureExperiment\")) pieces <- st_sf(geometry = pieces, sample_id = \"sample01\") annotGeometry(sfe_xen, \"pieces\") <- pieces # Getter, by name or index (tb <- annotGeometry(sfe_xen, \"pieces\")) #> Simple feature collection with 2 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: -1008.1 xmax: 1025.95 ymax: 0 #> CRS:           NA #>   sample_id                       geometry #> 1  sample01 POLYGON ((991.1 -252.45, 95... #> 2  sample01 POLYGON ((0 0, 0 -1008.1, 2... ggplot(tb) + geom_sf() plotGeometry(sfe_xen, annotGeometryName = \"pieces\", show_axes = TRUE) plotGeometry(sfe_xen, colGeometryName = \"cellSeg\", annotGeometryName = \"pieces\",              show_axes = TRUE) annotGeometryNames(sfe_xen) #> [1] \"pieces\""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"spatial-graphs","dir":"Articles","previous_headings":"Getting, setting, and plotting fields of SFE objects","what":"Spatial graphs","title":"Images and transcript spots in SFE","text":"spatial neighborhood graphs Visium spots stored colGraphs field, similar user interface colGeometries. SFE also wraps methods find spatial neighborhood graph implemented spdep package, triangulation used demonstration. Plot graph space  Alternatively use k nearest neighbor graph  graphs present SFE object? interesting see implications choice spatial neighborhood graph edge weights spatial analyses.","code":"(g <- findSpatialNeighbors(sfe_xen, MARGIN = 2, method = \"tri2nb\")) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 5749  #> Number of nonzero links: 34444  #> Percentage nonzero weights: 0.1042147  #> Average number of links: 5.991303  #>  #> Weights style: W  #> Weights constants summary: #>      n       nn   S0      S1       S2 #> W 5749 33051001 5749 1955.66 23350.69 # Set graph by name colGraph(sfe_xen, \"triangulation\") <- g # Get graph by name (g <- colGraph(sfe_xen, \"triangulation\")) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 5749  #> Number of nonzero links: 34444  #> Percentage nonzero weights: 0.1042147  #> Average number of links: 5.991303  #>  #> Weights style: W  #> Weights constants summary: #>      n       nn   S0      S1       S2 #> W 5749 33051001 5749 1955.66 23350.69 plotColGraph(sfe_xen, colGraphName = \"triangulation\") colGraph(sfe_xen, \"knn\") <- findSpatialNeighbors(sfe_xen, method = \"knearneigh\",                                                  k = 5) plotColGraph(sfe_xen, colGraphName = \"knn\") colGraphNames(sfe_xen) #> [1] \"triangulation\" \"knn\""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"images","dir":"Articles","previous_headings":"","what":"Images","title":"Images and transcript spots in SFE","text":"SPE, images used visualization, SFE extended SPE image functionality large images don’t loaded memory unless necessary. SFE extensible; image classes can implemented inheriting virtual class AlignedSpatialImage; “aligned” spatial extent must specified align image geometries, just like satellite image aligned vector geometries roads city boundaries. present, SFE package implements 3 types images: SpatRasterImage, BioFormatsImage, ExtImage.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"spatrasterimage","dir":"Articles","previous_headings":"Images","what":"SpatRasterImage","title":"Images and transcript spots in SFE","text":"SpatRasterImage default, thin wrapper around SpatRaster class terra object make conform SPE’s requirements. Large images loaded memory unless necessary ’s possible load sampled lower resolution version image memory. Spatial extent part SpatRaster. extent important delineate image coordinate system within tissue section. sophisticated way make sure image aligned geometries scale factor SPE works Visium allow SPE object cropped. MERFISH dataset , image represented SpatRasterImage. Get images getImg() function, use image_id function indicate image get, ’s left blank, first image retrieved: imgData() getter gets images SFE object displays summary including image dimension class see image_ids present SFE object Use ext function get extent image images SFE objects can plotted plotImage() function Voyager  SpatRasterImage, plot function terra (works SFE 1.7.0 later; earlier versions need call plot(imgRaster(img)))  image can plotted behind cell level data Voyager functions plot geometries  advantage SpatRasterImage one can use vector geometries sf data frames extract data raster image. binary mask, terra package can convert mask polygons vice versa. extract PolyT intensity values within cell see relate total transcript counts  way can relate data images cell level data, includes gene expression data. disadvantages, terra built geography ’s difficult perform affine transforms image (including rotation); geography transformation performed reprojecting map standards projections Mercator Robinson projections world map. SpatRasterImage rotated, ’s converted ExtImage, can converted back SpatRasterImage. BioFormatsImage can also converted SpatRasterImage though goes ExtImage. ExtImage thin wrapper around Image class EBImage package conform SPE’s requirements add spatial extent. ExtImage, one can thresholding morphological operations. However, ’s merely wrapper; contains another essential metadata field extent. BioFormatsImage loaded memory, becomes EBImage. convert image ExtImage, plot EBImage package; normalize() function called display() expects values 0 1.  EBImage, can apply tools image processing tradition, morphological operations. use Otsu threasholding automatically find threshold segment tissue followed opening operation remove small bits closing fill holes   mask can converted polygon SpatRasterImage terra::.polygons. mask still spatial extent, makes sure ’s still aligned geometries regardless pixel size. region value 0 (tissue) value 1 (tissue) converted polygons.  polygons can added back SFE object; say ’m interested value 1","code":"(img <- getImg(sfe_mer, image_id = \"PolyT_z3\")) #> 695 x 695 x 1 (width x height x channels) SpatRasterImage #> imgSource(): #>   /tmp/RtmpOVsuEd/vizgen/vizgen_cellbound/images/mosaic_PolyT_z3.tif imgData(sfe_mer) #> DataFrame with 5 rows and 4 columns #>     sample_id      image_id                          data scaleFactor #>   <character>   <character>                        <list>   <numeric> #> 1    sample01 Cellbound1_z3 695 x 695 x 1 SpatRasterImage           1 #> 2    sample01 Cellbound2_z3 695 x 695 x 1 SpatRasterImage           1 #> 3    sample01 Cellbound3_z3 695 x 695 x 1 SpatRasterImage           1 #> 4    sample01       DAPI_z3 695 x 695 x 1 SpatRasterImage           1 #> 5    sample01      PolyT_z3 695 x 695 x 1 SpatRasterImage           1 imageIDs(sfe_mer) #> [1] \"Cellbound1_z3\" \"Cellbound2_z3\" \"Cellbound3_z3\" \"DAPI_z3\"       #> [5] \"PolyT_z3\" ext(img) #>      xmin      xmax      ymin      ymax  #>  6499.909  6800.141 -1500.166 -1199.939 plotImage(sfe_mer, image_id = \"PolyT_z3\") plot(img) plotSpatialFeature(sfe_mer, features = \"transcript_count\",                     colGeometryName = \"cellSeg\",                    aes_use = \"color\", fill = NA, # Only color by cell outline                    image_id = \"PolyT_z3\", dark = TRUE) polyt_values <- terra::extract(img, cellSeg(sfe_mer)) polyt_sum <- polyt_values |>      group_by(ID) |>      summarize(polyt = sum(mosaic_PolyT_z3)) polyt_sum$total_counts <- sfe_mer$transcript_count ggplot(polyt_sum, aes(polyt, total_counts)) +     geom_point() +     geom_density2d(color = \"cornflowerblue\") ebi <- toExtImage(img) display(normalize(ebi)) th <- otsu(ebi, range = range(ebi), levels = max(ebi)) mask <- ebi > th display(mask) mask <- opening(mask) |> closing() display(mask) ext(mask) #>      xmin      xmax      ymin      ymax  #>  6499.909  6800.141 -1500.166 -1199.939 mask_spi <- toSpatRasterImage(mask) #> >>> Saving image with `.tiff` (non OME-TIFF) format: #> img.tiff (tb <- as.polygons(mask_spi) |> st_as_sf()) #> Simple feature collection with 2 features and 1 field #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: 6499.909 ymin: -1500.166 xmax: 6800.141 ymax: -1199.939 #> CRS:           NA #>   lyr.1                       geometry #> 1     0 MULTIPOLYGON (((6499.909 -1... #> 2     1 POLYGON ((6499.909 -1199.93... ggplot(tb, aes(fill = lyr.1)) + geom_sf() tb <- tb |>      filter(lyr.1 == 1L) |>      select(geometry) |>      mutate(sample_id = \"sample01\") tissueBoundary(sfe_mer) <- tb plotSpatialFeature(sfe_mer, features = \"transcript_count\", colGeometryName = \"cellSeg\",                    annotGeometryName = \"tissueBoundary\",                    aes_use = \"color\", fill = NA, # Only color by cell outline                    # Don't fill the tissue boundary either                    annot_fixed = list(fill = NA, color = \"magenta\"),                    image_id = \"PolyT_z3\", dark = TRUE)"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"bioformatsimage","dir":"Articles","previous_headings":"Images","what":"BioFormatsImage","title":"Images and transcript spots in SFE","text":"BioFormatsImage used OME-TIFF images whose compression can’t read terra. image loaded memory. ’s just metadata, includes file path, extent, origin (minimum value coordinates), affine transformation information apply transformation fly part image loaded memory. far functions related BioFormatsImage cater Xenium data. somewhat similar stars proxy objects, also metadata memory, another commonly used raster package stars. images Xenium dataset read BioFormatsImage images MERFISH dataset 1 channel, image 4 channels, DAPI, ATP1A1/CD45/E-Cadherin, 18S, AlphaSMA/Vimentin, order. images pyramids multiple resolutions; applications require highest resolution. file channel around 370 MB. metadata read R relevant portion image highest resolution necessary loaded memory needed, say plotting. One can select 3 channels (order RGB) plotting; channel must specified 3 channels image, may colorblind friendly  plot channels separately gray scale  color palette can changed  Multiple channels can plotted behind geometries cell level data (image example data highest resolution original data 10X website order reduce download time)  Converting image ExtImage load memory, one can select resolution pyramid load","code":"imgData(sfe_xen) #> DataFrame with 1 row and 4 columns #>     sample_id         image_id                            data scaleFactor #>   <character>      <character>                          <AsIs>   <numeric> #> 1    sample01 morphology_focus 1207 x 1186 x 4 BioFormatsImage           1 getImg(sfe_xen) #> X: 1207, Y: 1186, C: 4, Z: 1, T: 1, BioFormatsImage #> imgSource(): #>   /tmp/RtmpOVsuEd/xenium/xenium2/morphology_focus/morphology_focus_0000.ome.tif plotImage(sfe_xen, image_id = \"morphology_focus\", channel = 3:1,            normalize_channels = TRUE) plotImage(sfe_xen, image_id = \"morphology_focus\", channel = 1) +     plotImage(sfe_xen, image_id = \"morphology_focus\", channel = 2) plotImage(sfe_xen, image_id = \"morphology_focus\", channel = 1,            palette = viridis_pal()(255)) plotSpatialFeature(sfe_xen, genes_use[6], colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", image_id = \"morphology_focus\",                    fill = NA, aes_use = \"color\",                     tx_fixed = list(color = \"lightgray\"),                    channel = 3:1, bbox = bbox, dark = TRUE) (ebi2 <- toExtImage(getImg(sfe_xen), resolution = 2L)) #> 1207 x 1186 x 4 (width x height x channels) ExtImage # Use the arrows on the top left of the widget to see different channels display(normalize(ebi2)) #> Only the first frame of the image stack is displayed. #> To display all frames use 'all = TRUE'."},{"path":[]},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"bounding-box","dir":"Articles","previous_headings":"Spatial operations","what":"Bounding box","title":"Images and transcript spots in SFE","text":"bounding box geometry smallest rectangle contains geometry, get minimum maximum x coordinates y coordinates. can find bounding box individual sf data frames st_bbox sf package However, SFE object, multiple geometries, cell centroids, cell segmentation, nucleus segmentation, tissue boundary, transcript spots, , images. bbox function SFE aggregates bounding boxes geometries (optionally images) get overall bounding box SFE object:","code":"st_bbox(rg) #>          xmin          ymin          xmax          ymax  #>  1.159668e-03 -1.008098e+03  1.026159e+03 -4.473946e+00 bbox(sfe_xen) #>      xmin      ymin      xmax      ymax  #>     0.000 -1008.100  1026.163     0.000 # In this case the image is not larger than the geometries bbox(sfe_xen, include_image = TRUE) #>      xmin      ymin      xmax      ymax  #>     0.000 -1008.100  1026.163     0.000"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"cropping","dir":"Articles","previous_headings":"Spatial operations","what":"Cropping","title":"Images and transcript spots in SFE","text":"can think SFE object stack maps aligned, like National Map layers satellite images, land use, administrative boundaries, watersheds, rock formations, faults, etc. Cropping crop maps. One can crop either bounding box polygon shape. colGeometryName argument specifies colGeometry decide cell keep cropping. Using centroid different using cell polygon since polygon can slightly overlap bounding box centroid outside. Now 207 cells bounding box opposed around 6000 original. plot cropped SFE object  See documentation SpatialFeatureExperiment::crop() options, keeping cells entirely contained polygon used cropping using geometry exclude rather include cells.","code":"sfe_cropped <- crop(sfe_xen, bbox, colGeometryName = \"cellSeg\") bbox(sfe_cropped) #> xmin ymin xmax ymax  #>    0 -600  200 -400 dim(sfe_cropped) #> [1] 394 207 plotSpatialFeature(sfe_cropped, genes_use[6], colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", image_id = \"morphology_focus\",                    fill = NA, aes_use = \"color\",                     tx_fixed = list(color = \"lightgray\"),                    channel = 3:1, dark = TRUE)"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"transformation","dir":"Articles","previous_headings":"Spatial operations","what":"Transformation","title":"Images and transcript spots in SFE","text":"can rotate (right now multiples 90 degrees), mirror, transpose, translate SFE object, ’s canonical orientation like brain sections data different orientation read . geometries images transformed keeping aligned.  “Mirror” one named transformations; transformations include scale, transpose, rotate, translate. generally, can use transformation matrix affine transformation, say align dataset another dataset different modality serial section. can obtain transformation matrix BigWarp ImageJ example, one can manually annotate corresponding points adjacent sections. matrix M performs linear transformation, v translation. transformation can performed x-y plane present. Contributions allow non-linear transformation welcome.  happens image transformation? ’s still BioFormatsImage, means ’s metadata memory. affine transformation information stored metadata can queried transformation() similar st_geotransform stars package puts transformation metadata, resampling image. SFE, image resampled loaded memory ExtImage.","code":"sfe_mirror <- mirror(sfe_xen, direction = \"vertical\") plotSpatialFeature(sfe_mirror, genes_use[6], colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", image_id = \"morphology_focus\",                    fill = NA, aes_use = \"color\", linewidth = 0.15,                    tx_fixed = list(color = \"lightgray\"),                    channel = 3:1, dark = TRUE, normalize_channels = TRUE) # Here it's a rotation matrix but can be anything M <- matrix(c(cos(pi/6), sin(pi/6), -sin(pi/6), cos(pi/6)), ncol = 2) sfe_affine <- SpatialFeatureExperiment::affine(sfe_xen, M = M, v = c(0,0)) plotSpatialFeature(sfe_affine, genes_use[6], colGeometryName = \"cellSeg\",                     rowGeometryName = \"txSpots\", image_id = \"morphology_focus\",                    fill = NA, aes_use = \"color\", linewidth = 0.15,                    tx_fixed = list(color = \"lightgray\"),                    channel = 3:1, dark = TRUE, normalize_channels = TRUE) getImg(sfe_affine) #> X: 1207, Y: 1186, C: 4, Z: 1, T: 1, BioFormatsImage #> imgSource(): #>   /tmp/RtmpOVsuEd/xenium/xenium2/morphology_focus/morphology_focus_0000.ome.tif transformation(getImg(sfe_affine)) #> $M #>           [,1]       [,2] #> [1,] 0.8660254 -0.5000000 #> [2,] 0.5000000  0.8660254 #>  #> $v #> [1] 0 0 plotImage(sfe_affine, image_id = \"morphology_focus\", channel = 3:1,            normalize_channels = TRUE)"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"spatial-aggregation","dir":"Articles","previous_headings":"Spatial operations","what":"Spatial aggregation","title":"Images and transcript spots in SFE","text":"Imaging based technologies single cell resolution, widely used Visium . spatial neighborhood graph used ESDA, neighbors single cells mean something different neighbors Visium spots. addition, shown Voyager MERFISH vignette, negative Moran’s single cell level can become positive spatial binning. Negative spatial autocorrelation can coexist locally positive spatial autocorrelation longer length scale. correlogram based higher order neighbors one way explore spatial correlation changes length scales, though (least spdep implementation) pretty slow run doesn’t scale well hundreds thousands cells. SEraster package, spatial aggregation used greatly speed finding spatially variable genes nnSVG large datasets largely retaining performance single cell resolution. SFE (1.7.0 later) implements spatial aggregation, grid (square hexagonal) defined grid bin size also kind geometry. Aggregation can done either transcript level (number transcript spots per bin) cell level (use summary function sum mean summarize cell level data cells intersect covered bin). implementation general SEraster.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"transcript-level","dir":"Articles","previous_headings":"Spatial operations > Spatial aggregation","what":"Transcript level","title":"Images and transcript spots in SFE","text":"One can create SFE object directly transcript spot file output commercial technology (yet converted GeoParquet); use hexagonal bins, size 20 microns: default, new colGeometry spatial bins called “bins”, can changed new_geometry_name argument.  can also aggregate rowGeometry SFE object, square 50 micron bins","code":"data_dir <- XeniumOutput(\"v2\", file_path = file.path(fp, \"xenium\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> The downloaded files are in /tmp/RtmpOVsuEd/xenium/xenium2 sfe_agg <- aggregateTxTech(data_dir, tech = \"Xenium\", cellsize = 20,                             square = FALSE) sfe_agg #> class: SpatialFeatureExperiment  #> dim: 398 3068  #> metadata(0): #> assays(1): counts #> rownames(398): ABCC11 ACE2 ... VWA5A VWF #> rowData names(0): #> colnames(3068): 30 31 ... 3096 3097 #> colData names(1): sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : X Y #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: micron #> Geometries: #> colGeometries: bins (POLYGON)  #>  #> Graphs: #> sample01: sfe_agg$total_counts <- colSums(counts(sfe_agg)) plotSpatialFeature(sfe_agg, \"total_counts\") sfe_agg2 <- aggregate(sfe_xen, rowGeometryName = \"txSpots\", cellsize = 50) sfe_agg2$total_counts <- colSums(counts(sfe_agg2)) plotSpatialFeature(sfe_agg2, \"total_counts\")"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"esda-at-different-length-scales","dir":"Articles","previous_headings":"Spatial operations > Spatial aggregation","what":"ESDA at different length scales","title":"Images and transcript spots in SFE","text":"order repeated load transcript file memory aggregation multiple bin sizes, can load memory first data frame. Moran’s commonly used metric spatial autocorrelation. can compute Moran’s one features, say total counts; can done gene expression. compute Moran’s using different spatial neighborhood graphs, rook queen. Rook means two polygons adjacent touch edge, queen means can adjacent touch point, queen includes diagonal neighbors square grid rook . smallest bins look like  largest bins look like  results colData variables colFeatureData field.  rook tends higher Moran’s queen, makes sense center diagonal neighbors away. Spatial autocorrelation total counts positive scales. decreases longer scale first, increases . interesting compare bivariate Lee’s L multivariate MULTISPATI PCA spatial statistics across scales. also interesting compare results hexagonal grids rotations grid robust comparisons like SEraster paper, systematically investigate implications different spatial neighborhood graphs different edge weights downstream spatial analyses.","code":"tx_df <- read_parquet(file.path(data_dir, \"transcripts.parquet\")) areas <- seq(500,10000, by = 1000) binsizes <- sqrt(areas) sfes <- lapply(binsizes, function(s) aggregateTxTech(data_dir, df = tx_df, tech = \"Xenium\",                                                      cellsize = s)) sfes <- lapply(sfes, function(sfe) {     sfe$total_count <- colSums(counts(sfe))     colGraph(sfe, \"rook\") <- findSpatialNeighbors(sfe, type = \"bins\", method = \"poly2nb\",                                                   queen = FALSE)     colGraph(sfe, \"queen\") <- findSpatialNeighbors(sfe, type = \"bins\", method = \"poly2nb\",                                                    queen = TRUE)     sfe }) plotSpatialFeature(sfes[[1]], \"total_count\") plotSpatialFeature(sfes[[length(sfes)]], \"total_count\") sfes <- lapply(sfes, colDataMoransI, colGraphName = \"rook\", feature = \"total_count\") sfes <- lapply(sfes, colDataMoransI, colGraphName = \"queen\", feature = \"total_count\",                name = \"moran_queen\")  # Use name argument to store results under non-default name colFeatureData(sfes[[2]]) #> DataFrame with 2 rows and 3 columns #>             moran_sample01 K_sample01 moran_queen_sample01 #>                  <numeric>  <numeric>            <numeric> #> sample_id               NA         NA                   NA #> total_count       0.371837    5.64398             0.275386 morans_rook <- vapply(sfes,                        function(sfe)                            colFeatureData(sfe)[\"total_count\", \"moran_sample01\"],                        FUN.VALUE = numeric(1)) morans_queen <- vapply(sfes,                        function(sfe)                            colFeatureData(sfe)[\"total_count\", \"moran_queen_sample01\"],                        FUN.VALUE = numeric(1)) # colorblind friendly palette data(\"ditto_colors\") df_morans <- data.frame(rook = morans_rook,                         queen = morans_queen,                         sizes = binsizes) |>      pivot_longer(cols = -sizes, names_to = \"type\", values_to = \"moran\") ggplot(df_morans, aes(sizes, moran, color = type)) +     geom_point() +     geom_line() +     scale_color_manual(values = ditto_colors)"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"cell-level","dir":"Articles","previous_headings":"Spatial operations > Spatial aggregation","what":"Cell level","title":"Images and transcript spots in SFE","text":"can also spatially aggregate data cell level, say transcript spots unavailable something transcript count desired aggregation. can aggregate summing transcript counts cells whose centroids fall bin, use mean instead. functions allowed, long take numeric matrix input returns numeric vector length number rows input matrix, rowMedians. Note code lot faster run using sum mean behind scene, matrix multiplication used compute sum mean bin functions need loop bin, can parallelized BPPARAM argument. Let’s plot one genes space see implication choosing different aggregation functions  Note sum aggregation looks bit like cell density mean median aggregation, cells evenly distributed space cells bin, likely transcript counts well. Also, using sum, bins edge tissue full likely lower transcript counts. Aggregation geometry, just spatial grids, may facilitate comparison data adjacent sections different modalities, say Xenium spatial transcriptomics single molecule resolution MALDI-MSI spatial metabolomics data 20 micron resolution, Visium GeoMX DSP. ’re questions think carefully . choice transcript cell level function used aggregate cell level data affect appropriate data normalization. choice function used aggregate cell level data also implications downstream analyses. Also, cell level data cell partially overlaps bin? problem data overlapping extent different resolutions areas may may overlap called “spatial misalignment”, tradition Bayesian modeling data geography.","code":"sfe_sum <- aggregate(sfe_xen, colGeometryName = \"centroids\", cellsize = 40,                      square = FALSE, FUN = sum) sfe_mean <- aggregate(sfe_xen, colGeometryName = \"centroids\", cellsize = 40,                      square = FALSE, FUN = mean) sfe_median <- aggregate(sfe_xen, colGeometryName = \"centroids\", cellsize = 40,                      square = FALSE, FUN = rowMedians) p1 <- plotCellBin2D(sfe_xen, binwidth = 40, hex = TRUE) + theme_void() +     ggtitle(\"Cell density\") p2 <- plotSpatialFeature(sfe_sum, genes_use[6], exprs_values = \"counts\") +      ggtitle(\"Sum\") + scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) p3 <- plotSpatialFeature(sfe_mean, genes_use[6], exprs_values = \"counts\") +      ggtitle(\"Mean\") + scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) p4 <- plotSpatialFeature(sfe_median, genes_use[6], exprs_values = \"counts\") +     ggtitle(\"Median\") + scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) p1 + p2 + p3 + p4"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"split","dir":"Articles","previous_headings":"Spatial operations","what":"Split","title":"Images and transcript spots in SFE","text":"opposite aggregate split. ’s possible split SFE objects grid like previous section, can interesting interesting compute global spatial statistics separate SFE object bin sort local-ish spatial statistics, common application may separate different histological regions different pieces tissues imaged together, tissue microarray (TMA) applied Visium, MERFISH, Xenium, CosMX. can split polygons indicate different pieces tissue; cells intersect different polygons go different SFE objects","code":"ggplot(pieces) + geom_sf() sfes_pieces <- splitByCol(sfe_xen, pieces) # Combine them back as different samples sfes_pieces[[2]] <- changeSampleIDs(sfes_pieces[[2]], c(sample01 = \"sample02\")) sfe2 <- do.call(cbind, sfes_pieces) plotGeometry(sfe2, colGeometryName = \"cellSeg\") plotColGraph(sfe2, \"knn\")"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"esda-to-compare-samples","dir":"Articles","previous_headings":"Spatial operations","what":"ESDA to compare samples","title":"Images and transcript spots in SFE","text":"two samples really piece tissue original tissue 3 dimensional blood vessel tunnel 3D tissue. genes different levels spatial autocorrelation across two pieces? slightly local Moran’s computing Moran’s whole piece, strength spatial autocorrelation can lot heterogeneity. interesting two samples different biological conditions like healthy vs. pathological. just quick dirty comparison statistically rigorous. merely indicates something interesting, confirmed. data DelayedArray fully loaded memory, computing Moran’s genes slower dgCMatrix memory. gene expression, global spatial results stored rowData. Global spatial statistics return one result entire sample, regardless local heterogeneity. Local spatial statistics local Moran’s return one result location cell bin spot. results stored localResults field SFE objects, whose getters setters similar reducedDims whose plotting function plotLocalResult() similar plotSpatialFeature().  concordance correlation coefficient (CCC) shows well bivariate distribution follows y = x line. expected, since two pieces fact one, genes mostly similar Moran’s pieces. cool test whether difference Moran’s two pieces significant, just like testing whether mean different t-test. Whether difference significant even meaningful also depend heterogeneity spatial structure tissue type different 2D sections original 3D tissue, size pieces, questions asked; relevant variance Moran’s pieces size tissue type variance relevant just like t-tests.","code":"sfes_pieces <- lapply(sfes_pieces, runMoransI, colGraphName = \"knn\") rowData(sfes_pieces[[1]]) #> DataFrame with 394 rows and 5 columns #>                                             ID                 Symbol #>                                    <character>            <character> #> ABCC11                         ENSG00000121270                 ABCC11 #> ACE2                           ENSG00000130234                   ACE2 #> ACKR1                          ENSG00000213088                  ACKR1 #> ACTA2                          ENSG00000107796                  ACTA2 #> ACTG2                          ENSG00000163017                  ACTG2 #> ...                                        ...                    ... #> UnassignedCodeword_0461 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0469 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0479 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0488 UnassignedCodeword_0.. UnassignedCodeword_0.. #> UnassignedCodeword_0497 UnassignedCodeword_0.. UnassignedCodeword_0.. #>                                        Type moran_sample01 K_sample01 #>                                 <character>      <numeric>  <numeric> #> ABCC11                      Gene Expression    -0.00148686  791.96123 #> ACE2                        Gene Expression     0.34077210   23.85287 #> ACKR1                       Gene Expression     0.13361491  100.81951 #> ACTA2                       Gene Expression     0.11683337    9.60491 #> ACTG2                       Gene Expression     0.18008498    8.02017 #> ...                                     ...            ...        ... #> UnassignedCodeword_0461 Unassigned Codeword            NaN        NaN #> UnassignedCodeword_0469 Unassigned Codeword            NaN        NaN #> UnassignedCodeword_0479 Unassigned Codeword   -0.000474158       2108 #> UnassignedCodeword_0488 Unassigned Codeword            NaN        NaN #> UnassignedCodeword_0497 Unassigned Codeword            NaN        NaN morans_pieces <- cbind(rowData(sfes_pieces[[1]])[,c(\"Symbol\", \"Type\", \"moran_sample01\")],                        rowData(sfes_pieces[[2]])[,\"moran_sample02\", drop = FALSE]) |>      as.data.frame() morans_pieces <- morans_pieces |>      filter(Type == \"Gene Expression\") ggplot(morans_pieces, aes(moran_sample01, moran_sample02)) +     geom_point(alpha = 0.7) +     geom_abline(slope = 1, intercept = 0, color = \"blue\") +      geom_density2d(color = \"cornflowerblue\") +     coord_equal() metrica::CCC(obs = morans_pieces$moran_sample01, pred = morans_pieces$moran_sample02) #> $CCC #> [1] 0.8873082"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/articles/workshop.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Images and transcript spots in SFE","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8          LC_NUMERIC=C                  #>  [3] LC_TIME=en_US.UTF-8           LC_COLLATE=en_US.UTF-8        #>  [5] LC_MONETARY=en_US.UTF-8       LC_MESSAGES=en_US.UTF-8       #>  [7] LC_PAPER=en_US.UTF-8          LC_NAME=en_US.UTF-8           #>  [9] LC_ADDRESS=en_US.UTF-8        LC_TELEPHONE=en_US.UTF-8      #> [11] LC_MEASUREMENT=en_US.UTF-8    LC_IDENTIFICATION=en_US.UTF-8 #>  #> time zone: Etc/UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] metrica_2.1.0                  sparseMatrixStats_1.17.2       #>  [3] arrow_16.1.0                   stringr_1.5.1                  #>  [5] tibble_3.2.1                   tidyr_1.3.1                    #>  [7] dplyr_1.1.4                    patchwork_1.2.0                #>  [9] scales_1.3.0                   EBImage_4.47.0                 #> [11] Voyager_1.7.0                  SFEData_1.7.0                  #> [13] SpatialFeatureExperiment_1.7.1 SpatialExperiment_1.15.1       #> [15] scater_1.33.4                  scuttle_1.15.2                 #> [17] Seurat_5.1.0                   SeuratObject_5.0.2             #> [19] sp_2.1-4                       SingleCellExperiment_1.27.2    #> [21] SummarizedExperiment_1.35.1    Biobase_2.65.0                 #> [23] GenomicRanges_1.57.1           GenomeInfoDb_1.41.1            #> [25] IRanges_2.39.2                 S4Vectors_0.43.2               #> [27] BiocGenerics_0.51.0            MatrixGenerics_1.17.0          #> [29] matrixStats_1.3.0              ggplot2_3.5.1                  #> [31] terra_1.7-78                   fs_1.6.4                       #> [33] sf_1.0-16                      Matrix_1.7-0                   #> [35] BiocStyle_2.33.1               #>  #> loaded via a namespace (and not attached): #>   [1] R.methodsS3_1.8.2         tiff_0.1-12               #>   [3] RBioFormats_1.5.1         goftest_1.2-3             #>   [5] Biostrings_2.73.1         HDF5Array_1.33.5          #>   [7] vctrs_0.6.5               spatstat.random_3.3-1     #>   [9] energy_1.7-11             digest_0.6.36             #>  [11] png_0.1-8                 proxy_0.4-27              #>  [13] ggrepel_0.9.5             deldir_2.0-4              #>  [15] parallelly_1.37.1         magick_2.8.4              #>  [17] MASS_7.3-61               pkgdown_2.1.0             #>  [19] reshape2_1.4.4            httpuv_1.6.15             #>  [21] scico_1.5.0               withr_3.0.0               #>  [23] xfun_0.46                 survival_3.7-0            #>  [25] memoise_2.0.1             s2_1.1.7                  #>  [27] hexbin_1.28.3             ggbeeswarm_0.7.2          #>  [29] systemfonts_1.1.0         ragg_1.3.2                #>  [31] zoo_1.8-12                pbapply_1.7-2             #>  [33] R.oo_1.26.0               spData_2.3.1              #>  [35] KEGGREST_1.45.1           promises_1.3.0            #>  [37] httr_1.4.7                globals_0.16.3            #>  [39] fitdistrplus_1.2-1        rhdf5filters_1.17.0       #>  [41] rhdf5_2.49.0              UCSC.utils_1.1.0          #>  [43] units_0.8-5               miniUI_0.1.1.1            #>  [45] generics_0.1.3            curl_5.2.1                #>  [47] zlibbioc_1.51.1           ScaledMatrix_1.13.0       #>  [49] polyclip_1.10-6           GenomeInfoDbData_1.2.12   #>  [51] ExperimentHub_2.13.0      SparseArray_1.5.25        #>  [53] fftwtools_0.9-11          xtable_1.8-4              #>  [55] desc_1.4.3                evaluate_0.24.0           #>  [57] S4Arrays_1.5.5            BiocFileCache_2.13.0      #>  [59] bookdown_0.40             irlba_2.3.5.1             #>  [61] sfarrow_0.4.1             colorspace_2.1-0          #>  [63] filelock_1.0.3            isoband_0.2.7             #>  [65] ROCR_1.0-11               reticulate_1.38.0         #>  [67] spatstat.data_3.1-2       magrittr_2.0.3            #>  [69] lmtest_0.9-40             spdep_1.3-5               #>  [71] later_1.3.2               viridis_0.6.5             #>  [73] lattice_0.22-6            spatstat.geom_3.3-2       #>  [75] future.apply_1.11.2       scattermore_1.2           #>  [77] cowplot_1.1.3             RcppAnnoy_0.0.22          #>  [79] class_7.3-22              pillar_1.9.0              #>  [81] nlme_3.1-165              compiler_4.4.1            #>  [83] beachmat_2.21.4           RSpectra_0.16-2           #>  [85] stringi_1.8.4             tensor_1.5                #>  [87] plyr_1.8.9                crayon_1.5.3              #>  [89] abind_1.4-5               locfit_1.5-9.10           #>  [91] bit_4.0.5                 codetools_0.2-20          #>  [93] textshaping_0.4.0         BiocSingular_1.21.2       #>  [95] bslib_0.7.0               e1071_1.7-14              #>  [97] plotly_4.10.4             mime_0.12                 #>  [99] splines_4.4.1             Rcpp_1.0.13               #> [101] fastDummies_1.7.3         dbplyr_2.5.0              #> [103] knitr_1.48                blob_1.2.4                #> [105] utf8_1.2.4                BiocVersion_3.20.0        #> [107] listenv_0.9.1             DelayedMatrixStats_1.27.2 #> [109] gsl_2.1-8                 statmod_1.5.0             #> [111] pkgconfig_2.0.3           tools_4.4.1               #> [113] cachem_1.1.0              RSQLite_2.3.7             #> [115] viridisLite_0.4.2         DBI_1.2.3                 #> [117] minerva_1.5.10            fastmap_1.2.0             #> [119] rmarkdown_2.27            grid_4.4.1                #> [121] ica_1.0-3                 AnnotationHub_3.13.0      #> [123] sass_0.4.9                BiocManager_1.30.23       #> [125] dotCall64_1.1-1           RANN_2.6.1                #> [127] farver_2.1.2              wk_0.9.2                  #> [129] yaml_2.3.9                cli_3.6.3                 #> [131] purrr_1.0.2               leiden_0.4.3.1            #> [133] lifecycle_1.0.4           uwot_0.2.2                #> [135] bluster_1.15.0            DropletUtils_1.25.0       #> [137] BiocParallel_1.39.0       gtable_0.3.5              #> [139] rjson_0.2.21              ggridges_0.5.6            #> [141] progressr_0.14.0          parallel_4.4.1            #> [143] limma_3.61.5              jsonlite_1.8.8            #> [145] edgeR_4.3.5               RcppHNSW_0.6.0            #> [147] bitops_1.0-7              bit64_4.0.5               #> [149] assertthat_0.2.1          Rtsne_0.17                #> [151] spatstat.utils_3.0-5      BiocNeighbors_1.23.0      #> [153] jquerylib_0.1.4           highr_0.11                #> [155] dqrng_0.4.1               zeallot_0.1.0             #> [157] spatstat.univar_3.0-0     R.utils_2.12.3            #> [159] lazyeval_0.2.2            shiny_1.8.1.1             #> [161] htmltools_0.5.8.1         rJava_1.0-11              #> [163] sctransform_0.4.1         rappdirs_0.3.3            #> [165] glue_1.7.0                spam_2.10-0               #> [167] XVector_0.45.0            RCurl_1.98-1.16           #> [169] classInt_0.4-10           jpeg_0.1-10               #> [171] gridExtra_2.3             boot_1.3-30               #> [173] igraph_2.0.3              R6_2.5.1                  #> [175] labeling_0.4.3            cluster_2.1.6             #> [177] Rhdf5lib_1.27.0           memuse_4.2-3              #> [179] DelayedArray_0.31.9       tidyselect_1.2.1          #> [181] vipor_0.4.7               xml2_1.3.6                #> [183] AnnotationDbi_1.67.0      future_1.33.2             #> [185] sfheaders_0.4.4           rsvd_1.0.5                #> [187] munsell_0.5.1             KernSmooth_2.23-24        #> [189] data.table_1.15.4         htmlwidgets_1.6.4         #> [191] RColorBrewer_1.1-3        rlang_1.1.4               #> [193] spatstat.sparse_3.1-0     spatstat.explore_3.3-1    #> [195] ggnewscale_0.5.0          fansi_1.0.6               #> [197] beeswarm_0.4.0"},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lambda Moses. Author, maintainer. Alik Huseynov. Author. Lior Pachter. Author, thesis advisor.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Moses L, Huseynov , Pachter L (2024). SFEWorkshop2024: Multiscale ESDA SpatialFeatureExperiment Voyager. R package version 0.99.0, https://lambdamoses.github.io/SFEWorkshop2024/.","code":"@Manual{,   title = {SFEWorkshop2024: Multiscale ESDA with SpatialFeatureExperiment and Voyager},   author = {Lambda Moses and Alik Huseynov and Lior Pachter},   year = {2024},   note = {R package version 0.99.0},   url = {https://lambdamoses.github.io/SFEWorkshop2024/}, }"},{"path":[]},{"path":[]},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"description","dir":"","previous_headings":"Overview","what":"Description","title":"SFEWorkshop2024","text":"Exploratory spatial data analysis (ESDA) can powerful approach understanding single-cell genomics datasets, yet part standard data analysis workflows. particular, geospatial analyses, developed refined decades, yet fully adapted applied spatial single-cell analysis. introduce Voyager platform, systematically brings geospatial ESDA tradition (spatial) -omics, local, bivariate, multivariate spatial methods yet commonly applied spatial -omics, united uniform user interface. Using Voyager, showcase biological insights can derived methods, biologically relevant negative spatial autocorrelation. Underlying Voyager SpatialFeatureExperiment (SFE) data structure, combines Simple Feature SingleCellExperiment AnnData represent operate geometries bundled gene expression data. Voyager comprehensive tutorials demonstrating ESDA built GitHub Actions ensure reproducibility scalability, using data popular commercial technologies. Voyager implemented R/Bioconductor Python/PyPI, features compatibility tests ensure implementations return consistent results. workshop focuses new features SFE Voyager implemented past year. Earlier features described details preprint 2023 Voyager workshop. preprint soon updated include new functionalities prior submission. new features fall areas: Expanded support images. new image class BioFormatsImage implemented support OME-TIFF Xenium ExtImage class support image processing EBImage package. Support transcript spot geometries. Coordinates smFISH-based technologies reformatted faster reading next time, stored rowGeometries field SFE object. simple features, geometric operations sf can applied. Support images transcript spots led improved functions read output commercial technologies: Vizgen MERFISH, Xenium, CosMX. ’re working VisiumHD. Expanded support affine transformations. Affine transformation can performed transformation matrix, images geometries transformed remaining aligned. New spatial operations SFE objects: spatial aggregation (cell transcript spot levels) splitting geometries.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"pre-requisites","dir":"","previous_headings":"Overview","what":"Pre-requisites","title":"SFEWorkshop2024","text":"understand workshop material, expected : Intermediate knowledge R syntax least basic familiarity Tidyverse ggplot2 Familiarity sf encouraged. Read Geocomputing R intro sf geospatial data. helpful take look last year’s Voyager workshop; year ’m covering math behind ESDA, order focus new functionalities.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"participation","dir":"","previous_headings":"Overview","what":"Participation","title":"SFEWorkshop2024","text":"workshop consists hands demos, exercises, Q&.","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"r--bioconductor-packages-used","dir":"","previous_headings":"Overview","what":"R / Bioconductor packages used","title":"SFEWorkshop2024","text":"Voyager SpatialFeatureExperiment SFEData scater scran SingleCellExperiment EBImage RBioFormats sparseMatrixStats DelayedArray","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"time-outline","dir":"","previous_headings":"Overview","what":"Time outline","title":"SFEWorkshop2024","text":"Total: 90 minutes","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"workshop-goals-and-objectives","dir":"","previous_headings":"Overview","what":"Workshop goals and objectives","title":"SFEWorkshop2024","text":"Learn basics SFE Voyager ESDA Learn work images transcript spots SFE Discussion ESDA ideas different lengths scales samples","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"what-you-will-learn","dir":"","previous_headings":"Overview > Workshop goals and objectives","what":"What you will learn","title":"SFEWorkshop2024","text":"Use operate SFE objects Spatial data visualization Geometric operations Create spatial neighborhood graphs Run spatial analyses different fields SFE objects Visualize spatial analysis results","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"what-you-will-not-learn","dir":"","previous_headings":"Overview > Workshop goals and objectives","what":"What you will not learn","title":"SFEWorkshop2024","text":"Technologies collect spatial transcriptomics data Data integration across multiple samples Spatial multi-omics","code":""},{"path":"https://lambdamoses.github.io/SFEWorkshop2024/index.html","id":"to-use-the-docker-image","dir":"","previous_headings":"","what":"To use the Docker image","title":"SFEWorkshop2024","text":"workshop can run remotely Bioconductor Workshop Galaxy. Alternatively, can run locally Docker image: running, navigate http://localhost:8787/ log rstudio:yourchosenpassword. required packages appropriate version July 2024 pre-installed Workshop Galaxy Docker image. Devel versions SFE, Voyager, Bioconductor July 2024 used .","code":"docker run -e PASSWORD=<choose_a_password_for_rstudio> -p 8787:8787 ghcr.io/lambdamoses/sfeworkshop2024"}]
